/**
 * CVE Scanner
 * Integrates with CVE databases (NVD, OSV) to identify vulnerabilities
 * Requirement: 21.3
 */

import type { Component } from "./sbom-generator.js";

export interface CVE {
  id: string;
  source: "NVD" | "OSV" | "GITHUB" | "OTHER";
  severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | "UNKNOWN";
  cvssScore?: number;
  cvssVector?: string;
  description: string;
  publishedDate: string;
  lastModifiedDate: string;
  affectedVersions: string[];
  fixedVersions: string[];
  references: string[];
  cwe?: string[];
  remediation?: string;
}

export interface VulnerabilityMatch {
  component: Component;
  cves: CVE[];
  riskLevel: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";
  remediationRecommendations: string[];
}

export interface CVEScanResult {
  totalComponents: number;
  vulnerableComponents: number;
  totalCVEs: number;
  criticalCVEs: number;
  highCVEs: number;
  mediumCVEs: number;
  lowCVEs: number;
  matches: VulnerabilityMatch[];
  scanDuration: number;
}

export interface CVEScannerOptions {
  ttlMs?: number;
  fetch?: typeof fetch;
  now?: () => number;
}

interface CacheEntry {
  expiresAt: number;
  cves: CVE[];
}

interface OsvResponse {
  vulns?: OsvVulnerability[];
}

interface OsvVulnerability {
  id: string;
  summary?: string;
  details?: string;
  published?: string;
  modified?: string;
  severity?: Array<{ type: string; score: string }>;
  references?: Array<{ url: string }>;
  affected?: Array<{ ranges?: Array<{ events?: Array<{ fixed?: string }> }> }>;
}

interface SummaryCounters {
  matches: VulnerabilityMatch[];
  totalCVEs: number;
  criticalCVEs: number;
  highCVEs: number;
  mediumCVEs: number;
  lowCVEs: number;
}

/**
 * CVE Scanner class
 */
export class CVEScanner {
  private readonly cache = new Map<string, CacheEntry>();
  private readonly ttlMs: number;
  private readonly fetcher: typeof fetch;
  private readonly now: () => number;

  constructor(options: CVEScannerOptions = {}) {
    this.ttlMs = options.ttlMs ?? 1000 * 60 * 60 * 24;
    this.fetcher = options.fetch ?? fetch;
    this.now = options.now ?? Date.now;
  }

  async scanComponents(components: Component[]): Promise<CVEScanResult> {
    const start = this.now();
    const counters = createSummaryCounters();

    for (const component of components) {
      const cves = await this.lookupComponent(component);
      if (cves.length === 0) {
        continue;
      }
      counters.matches.push(this.buildMatch(component, cves));
      incrementSeverityCounters(counters, cves);
    }

    const duration = this.now() - start;
    return finalizeCounters(counters, components.length, duration > 0 ? duration : 1);
  }

  private async lookupComponent(component: Component): Promise<CVE[]> {
    try {
      return await this.queryCVEDatabase(component);
    } catch {
      return [];
    }
  }

  private async queryCVEDatabase(component: Component): Promise<CVE[]> {
    const cached = this.readCache(component);
    if (cached) {
      return cached;
    }

    const cves: CVE[] = [];
    cves.push(...(await this.queryNVD(component)));
    cves.push(...(await this.queryOSV(component)));

    const deduped = this.deduplicateCVEs(cves);
    this.writeCache(component, deduped);
    return deduped;
  }

  private async queryNVD(component: Component): Promise<CVE[]> {
    void component;
    return [];
  }

  private async queryOSV(component: Component): Promise<CVE[]> {
    if (!component.purl) {
      return [];
    }

    const response = await this.safeFetch("https://api.osv.dev/v1/query", {
      package: { purl: component.purl },
      version: component.version,
    });

    if (!response?.vulns) {
      return [];
    }

    return response.vulns
      .map((vuln) => this.mapOsvVulnerability(component, vuln))
      .filter((cve): cve is CVE => cve !== null);
  }

  private async safeFetch(url: string, body: unknown): Promise<OsvResponse | null> {
    try {
      const response = await this.fetcher(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });
      if (!response.ok) {
        return null;
      }
      return (await response.json()) as OsvResponse;
    } catch {
      return null;
    }
  }

  private mapOsvVulnerability(component: Component, vuln: OsvVulnerability): CVE | null {
    const score = extractCvssScore(vuln);
    return {
      id: vuln.id,
      source: "OSV",
      severity: this.mapCVSSSeverity(score),
      cvssScore: score,
      description: vuln.summary || vuln.details || "No description available",
      publishedDate: vuln.published || "",
      lastModifiedDate: vuln.modified || "",
      affectedVersions: [component.version],
      fixedVersions: collectFixedVersions(vuln),
      references: (vuln.references ?? []).map((ref) => ref.url),
    };
  }

  private buildMatch(component: Component, cves: CVE[]): VulnerabilityMatch {
    return {
      component,
      cves,
      riskLevel: this.calculateRiskLevel(cves),
      remediationRecommendations: this.generateRemediationRecommendations(
        component,
        cves,
      ),
    };
  }

  private deduplicateCVEs(cves: CVE[]): CVE[] {
    const seen = new Map<string, CVE>();
    for (const cve of cves) {
      if (!seen.has(cve.id)) {
        seen.set(cve.id, cve);
      }
    }
    return Array.from(seen.values());
  }

  private readCache(component: Component): CVE[] | null {
    const key = buildCacheKey(component);
    const entry = this.cache.get(key);
    if (!entry) {
      return null;
    }
    if (entry.expiresAt < this.now()) {
      this.cache.delete(key);
      return null;
    }
    return entry.cves;
  }

  private writeCache(component: Component, cves: CVE[]): void {
    const key = buildCacheKey(component);
    this.cache.set(key, { expiresAt: this.now() + this.ttlMs, cves });
  }

  private calculateRiskLevel(cves: CVE[]): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" {
    if (cves.some((cve) => cve.severity === "CRITICAL")) return "CRITICAL";
    if (cves.some((cve) => cve.severity === "HIGH")) return "HIGH";
    if (cves.some((cve) => cve.severity === "MEDIUM")) return "MEDIUM";
    return "LOW";
  }

  private generateRemediationRecommendations(component: Component, cves: CVE[]): string[] {
    const recommendations: string[] = [];
    const fixedVersions = new Set<string>();
    for (const cve of cves) {
      for (const version of cve.fixedVersions) {
        fixedVersions.add(version);
      }
    }
    if (fixedVersions.size > 0) {
      const latest = Array.from(fixedVersions).sort().at(-1);
      if (latest) {
        recommendations.push(`Update ${component.name} from ${component.version} to ${latest} or later`);
      }
    } else {
      recommendations.push(`No fixed version available for ${component.name}. Consider workarounds or alternative packages.`);
    }
    const critical = cves.filter((cve) => cve.severity === "CRITICAL").length;
    if (critical > 0) {
      recommendations.push(`URGENT: ${critical} critical vulnerabilities detected. Immediate action required.`);
    }
    const cwes = new Set<string>();
    for (const cve of cves) {
      for (const cwe of cve.cwe ?? []) {
        cwes.add(cwe);
      }
    }
    if (cwes.size > 0) {
      recommendations.push(`Review CWE categories: ${Array.from(cwes).join(", ")}`);
    }
    return recommendations;
  }

  private mapCVSSSeverity(score?: number): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | "UNKNOWN" {
    if (score === undefined) return "UNKNOWN";
    if (score >= 9.0) return "CRITICAL";
    if (score >= 7.0) return "HIGH";
    if (score >= 4.0) return "MEDIUM";
    return "LOW";
  }
}

function buildCacheKey(component: Component): string {
  if (component.purl) return component.purl;
  return `${component.name}@${component.version}`;
}

function extractCvssScore(vuln: OsvVulnerability): number | undefined {
  const entry = vuln.severity?.find((item) => item.type === "CVSS_V3");
  if (!entry) return undefined;
  const parsed = Number.parseFloat(entry.score);
  return Number.isFinite(parsed) ? parsed : undefined;
}

function collectFixedVersions(vuln: OsvVulnerability): string[] {
  const versions = new Set<string>();
  for (const affected of vuln.affected ?? []) {
    for (const range of affected.ranges ?? []) {
      for (const event of range.events ?? []) {
        if (event.fixed) {
          versions.add(event.fixed);
        }
      }
    }
  }
  return Array.from(versions);
}

function createSummaryCounters(): SummaryCounters {
  return {
    matches: [],
    totalCVEs: 0,
    criticalCVEs: 0,
    highCVEs: 0,
    mediumCVEs: 0,
    lowCVEs: 0,
  };
}

function incrementSeverityCounters(summary: SummaryCounters, cves: CVE[]): void {
  summary.totalCVEs += cves.length;
  for (const cve of cves) {
    switch (cve.severity) {
      case "CRITICAL":
        summary.criticalCVEs++;
        break;
      case "HIGH":
        summary.highCVEs++;
        break;
      case "MEDIUM":
        summary.mediumCVEs++;
        break;
      case "LOW":
        summary.lowCVEs++;
        break;
    }
  }
}

function finalizeCounters(summary: SummaryCounters, totalComponents: number, duration: number): CVEScanResult {
  return {
    totalComponents,
    vulnerableComponents: summary.matches.length,
    totalCVEs: summary.totalCVEs,
    criticalCVEs: summary.criticalCVEs,
    highCVEs: summary.highCVEs,
    mediumCVEs: summary.mediumCVEs,
    lowCVEs: summary.lowCVEs,
    matches: summary.matches,
    scanDuration: duration,
  };
}
