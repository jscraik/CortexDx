/**
 * CVE Scanner
 * Integrates with CVE databases (NVD, OSV) to identify vulnerabilities
 * Requirement: 21.3
 */

import type { Component } from "./sbom-generator.js";

export interface CVE {
  id: string;
  source: "NVD" | "OSV" | "GITHUB" | "OTHER";
  severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | "UNKNOWN";
  cvssScore?: number;
  cvssVector?: string;
  description: string;
  publishedDate: string;
  lastModifiedDate: string;
  affectedVersions: string[];
  fixedVersions: string[];
  references: string[];
  cwe?: string[];
  remediation?: string;
}

export interface VulnerabilityMatch {
  component: Component;
  cves: CVE[];
  riskLevel: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";
  remediationRecommendations: string[];
}

export interface CVEScanResult {
  totalComponents: number;
  vulnerableComponents: number;
  totalCVEs: number;
  criticalCVEs: number;
  highCVEs: number;
  mediumCVEs: number;
  lowCVEs: number;
  matches: VulnerabilityMatch[];
  scanDuration: number;
}

/**
 * CVE Scanner class
 */
export class CVEScanner {
  /**
   * Scan components for known CVEs
   */
  async scanComponents(components: Component[]): Promise<CVEScanResult> {
    const startTime = Date.now();
    const matches: VulnerabilityMatch[] = [];

    let totalCVEs = 0;
    let criticalCVEs = 0;
    let highCVEs = 0;
    let mediumCVEs = 0;
    let lowCVEs = 0;

    for (const component of components) {
      const cves = await this.queryCVEDatabase(component);

      if (cves.length > 0) {
        const riskLevel = this.calculateRiskLevel(cves);
        const recommendations = this.generateRemediationRecommendations(
          component,
          cves,
        );

        matches.push({
          component,
          cves,
          riskLevel,
          remediationRecommendations: recommendations,
        });

        totalCVEs += cves.length;

        for (const cve of cves) {
          switch (cve.severity) {
            case "CRITICAL":
              criticalCVEs++;
              break;
            case "HIGH":
              highCVEs++;
              break;
            case "MEDIUM":
              mediumCVEs++;
              break;
            case "LOW":
              lowCVEs++;
              break;
          }
        }
      }
    }

    const scanDuration = Date.now() - startTime;

    return {
      totalComponents: components.length,
      vulnerableComponents: matches.length,
      totalCVEs,
      criticalCVEs,
      highCVEs,
      mediumCVEs,
      lowCVEs,
      matches,
      scanDuration,
    };
  }

  /**
   * Query CVE database for component vulnerabilities
   */
  private async queryCVEDatabase(component: Component): Promise<CVE[]> {
    const cves: CVE[] = [];

    // Try NVD first
    const nvdCVEs = await this.queryNVD(component);
    cves.push(...nvdCVEs);

    // Try OSV
    const osvCVEs = await this.queryOSV(component);
    cves.push(...osvCVEs);

    // Deduplicate CVEs
    return this.deduplicateCVEs(cves);
  }

  /**
   * Query National Vulnerability Database (NVD)
   */
  private async queryNVD(component: Component): Promise<CVE[]> {
    // Placeholder implementation
    // In production, this would call the NVD API
    // https://nvd.nist.gov/developers/vulnerabilities

    // For now, return empty array
    return [];
  }

  /**
   * Query Open Source Vulnerabilities (OSV) database
   */
  private async queryOSV(component: Component): Promise<CVE[]> {
    // Placeholder implementation
    // In production, this would call the OSV API
    // https://osv.dev/docs/

    try {
      if (!component.purl) {
        return [];
      }

      const response = await fetch("https://api.osv.dev/v1/query", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          package: {
            purl: component.purl,
          },
          version: component.version,
        }),
      });

      if (!response.ok) {
        return [];
      }

      const data = (await response.json()) as {
        vulns?: Array<{
          id: string;
          summary?: string;
          details?: string;
          published?: string;
          modified?: string;
          severity?: Array<{
            type: string;
            score: string;
          }>;
          references?: Array<{
            url: string;
          }>;
          affected?: Array<{
            ranges?: Array<{
              events?: Array<{
                introduced?: string;
                fixed?: string;
              }>;
            }>;
          }>;
        }>;
      };

      if (!data.vulns) {
        return [];
      }

      return data.vulns.map((vuln) => {
        const cvssScore = vuln.severity?.find(
          (s) => s.type === "CVSS_V3",
        )?.score;
        const severity = this.mapCVSSSeverity(
          cvssScore ? Number.parseFloat(cvssScore) : undefined,
        );

        const fixedVersions: string[] = [];
        if (vuln.affected) {
          for (const affected of vuln.affected) {
            if (affected.ranges) {
              for (const range of affected.ranges) {
                if (range.events) {
                  for (const event of range.events) {
                    if (event.fixed) {
                      fixedVersions.push(event.fixed);
                    }
                  }
                }
              }
            }
          }
        }

        return {
          id: vuln.id,
          source: "OSV" as const,
          severity,
          cvssScore: cvssScore ? Number.parseFloat(cvssScore) : undefined,
          description:
            vuln.summary || vuln.details || "No description available",
          publishedDate: vuln.published || "",
          lastModifiedDate: vuln.modified || "",
          affectedVersions: [component.version],
          fixedVersions,
          references: vuln.references?.map((r) => r.url) || [],
        };
      });
    } catch (error) {
      // Silently fail and return empty array
      return [];
    }
  }

  /**
   * Map CVSS score to severity
   */
  private mapCVSSSeverity(
    score?: number,
  ): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | "UNKNOWN" {
    if (!score) return "UNKNOWN";
    if (score >= 9.0) return "CRITICAL";
    if (score >= 7.0) return "HIGH";
    if (score >= 4.0) return "MEDIUM";
    return "LOW";
  }

  /**
   * Deduplicate CVEs by ID
   */
  private deduplicateCVEs(cves: CVE[]): CVE[] {
    const seen = new Map<string, CVE>();

    for (const cve of cves) {
      if (!seen.has(cve.id)) {
        seen.set(cve.id, cve);
      }
    }

    return Array.from(seen.values());
  }

  /**
   * Calculate overall risk level for a component
   */
  private calculateRiskLevel(
    cves: CVE[],
  ): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" {
    if (cves.some((cve) => cve.severity === "CRITICAL")) {
      return "CRITICAL";
    }
    if (cves.some((cve) => cve.severity === "HIGH")) {
      return "HIGH";
    }
    if (cves.some((cve) => cve.severity === "MEDIUM")) {
      return "MEDIUM";
    }
    return "LOW";
  }

  /**
   * Generate remediation recommendations
   */
  private generateRemediationRecommendations(
    component: Component,
    cves: CVE[],
  ): string[] {
    const recommendations: string[] = [];

    // Find the highest fixed version
    const fixedVersions = new Set<string>();
    for (const cve of cves) {
      for (const version of cve.fixedVersions) {
        fixedVersions.add(version);
      }
    }

    if (fixedVersions.size > 0) {
      const versions = Array.from(fixedVersions).sort();
      const latestFixed = versions[versions.length - 1];
      recommendations.push(
        `Update ${component.name} from ${component.version} to ${latestFixed} or later`,
      );
    } else {
      recommendations.push(
        `No fixed version available for ${component.name}. Consider alternative packages or apply workarounds.`,
      );
    }

    // Add severity-specific recommendations
    const criticalCVEs = cves.filter((cve) => cve.severity === "CRITICAL");
    if (criticalCVEs.length > 0) {
      recommendations.push(
        `URGENT: ${criticalCVEs.length} critical vulnerabilities detected. Immediate action required.`,
      );
    }

    // Add CWE-specific recommendations
    const cwes = new Set<string>();
    for (const cve of cves) {
      if (cve.cwe) {
        for (const cwe of cve.cwe) {
          cwes.add(cwe);
        }
      }
    }

    if (cwes.size > 0) {
      recommendations.push(
        `Review CWE categories: ${Array.from(cwes).join(", ")}`,
      );
    }

    return recommendations;
  }
}
