/**
 * Shell Completion Generator
 *
 * Generates shell completion scripts for bash, zsh, and fish.
 * Provides tab completion for commands, flags, and arguments.
 */

import type { Command } from "commander";

/**
 * Completion options
 */
export interface CompletionOptions {
  /** CLI name (e.g., "cortexdx") */
  name: string;
  /** CLI description */
  description?: string;
  /** Path to completion script output */
  outputDir?: string;
}

/**
 * Generate bash completion script
 */
export function generateBashCompletion(
  program: Command,
  options: CompletionOptions,
): string {
  const { name } = options;

  return `# Bash completion for ${name}
# Generated by ${name}

_${name}_completion() {
    local cur prev words cword
    _init_completion || return

    # Command completion
    if [[ \${cword} -eq 1 ]]; then
        COMPREPLY=($(compgen -W "${getCommandNames(program).join(" ")}" -- "\${cur}"))
        return
    fi

    # Flag completion
    case "\${prev}" in
        ${generateBashFlagCases(program)}
        *)
            ;;
    esac
}

complete -F _${name}_completion ${name}
`;
}

/**
 * Generate zsh completion script
 */
export function generateZshCompletion(
  program: Command,
  options: CompletionOptions,
): string {
  const { name } = options;

  return `#compdef ${name}
# Zsh completion for ${name}

_${name}() {
    local -a commands
    commands=(
${generateZshCommandList(program)}
    )

    if (( CURRENT == 2 )); then
        _describe 'command' commands
    else
        case \$words[2] in
${generateZshCommandCases(program)}
        esac
    fi
}

_${name}
`;
}

/**
 * Generate fish completion script
 */
export function generateFishCompletion(
  program: Command,
  options: CompletionOptions,
): string {
  const { name } = options;

  return `# Fish completion for ${name}
# Generated by ${name}

complete -c ${name} -f

${generateFishCommandCompletions(program)}

${generateFishFlagCompletions(program)}
`;
}

/**
 * Extract all command names from a Commander program
 */
function getCommandNames(program: Command): string[] {
  const commands: string[] = [];
  for (const cmd of program.commands) {
    commands.push(cmd.name());
    // Include aliases
    for (const alias of cmd.aliases) {
      commands.push(alias);
    }
  }
  return commands;
}

/**
 * Extract all global flags from a Commander program
 */
function getGlobalFlags(_program: Command): Array<{ name: string; description: string }> {
  const flags: Array<{ name: string; description: string }> = [];
  // Common global flags that should be in every CLI
  const commonFlags = [
    { name: "--help", description: "Show help" },
    { name: "--version", description: "Show version" },
    { name: "--quiet", description: "Suppress non-essential output" },
    { name: "--verbose", description: "Include diagnostics" },
    { name: "--debug", description: "Include internal detail" },
    { name: "--json", description: "Output in JSON format" },
    { name: "--plain", description: "Output in plain format" },
    { name: "--no-input", description: "Disable interactive prompts" },
    { name: "--no-color", description: "Disable ANSI colors" },
    { name: "--dry-run", description: "Preview without making changes" },
  ];
  return [...commonFlags, ...flags];
}

/**
 * Generate bash flag case statements
 */
function generateBashFlagCases(program: Command): string {
  const flags = getGlobalFlags(program);
  return flags
    .map((flag) => `        ${flag.name})
            COMPREPLY=($(compgen -W "" -- "\${cur}"))
            ;;
`)
    .join("\n");
}

/**
 * Generate zsh command list
 */
function generateZshCommandList(program: Command): string {
  const commands = getCommandNames(program);
  return commands.map((cmd) => `        '${cmd}:${cmd.replace("-", " ")}'`).join("\n");
}

/**
 * Generate zsh command cases
 */
function generateZshCommandCases(program: Command): string {
  let cases = "";
  for (const cmd of program.commands) {
    cases += `            ${cmd.name()})\n`;
    cases += `                # ${cmd.description()}\n`;
    cases += "                ;;\n";
  }
  return cases;
}

/**
 * Generate fish command completions
 */
function generateFishCommandCompletions(program: Command): string {
  const commands = getCommandNames(program);
  return commands
    .map((cmd) => `complete -c ${program.name()} -f -n "__fish_use_subcommand" -a ${cmd}`)
    .join("\n");
}

/**
 * Generate fish flag completions
 */
function generateFishFlagCompletions(program: Command): string {
  const flags = getGlobalFlags(program);
  return flags
    .map((flag) => `complete -c ${program.name()} -l ${flag.name.replace("--", "")} -d '${flag.description}'`)
    .join("\n");
}

/**
 * Get completion script for a specific shell
 */
export function getCompletionScript(
  shell: "bash" | "zsh" | "fish",
  program: Command,
  options: CompletionOptions,
): string {
  switch (shell) {
    case "bash":
      return generateBashCompletion(program, options);
    case "zsh":
      return generateZshCompletion(program, options);
    case "fish":
      return generateFishCompletion(program, options);
  }
}

/**
 * Installation instructions for completions
 */
export function getCompletionInstructions(
  name: string,
  shell: "bash" | "zsh" | "fish",
): string {
  const instructions: Record<string, string> = {
    bash: `# Bash completion for ${name}
# Add to ~/.bashrc or ~/.bash_profile:

eval "\$(${name} completion bash)"

# Or source the completion file directly:
# source <(${name} completion bash)
`,

    zsh: `# Zsh completion for ${name}
# Add to ~/.zshrc:

# autoload -U compinit && compinit
# eval "\$(${name} completion zsh)"

# Or place the completion file in:
# ~/.zsh/completion/_${name}
# and add to ~/.zshrc:
# fpath=(~/.zsh/completion \$fpath)
# autoload -U compinit && compinit
`,

    fish: `# Fish completion for ${name}
# Add to ~/.config/fish/completions/${name}.fish
# Or run once:

${name} completion fish > ~/.config/fish/completions/${name}.fish
`,
  };

  return instructions[shell];
}

/**
 * Simple completion generator for basic shells
 * This is a simplified version that works without Commander introspection
 */
export function generateSimpleCompletions(options: CompletionOptions): string {
  const { name } = options;

  return `#!/usr/bin/env bash
# Simple completion script for ${name}

_${name}_completions() {
    local cur="\${COMP_WORDS[COMP_CWORD]}"
    local prev="\${COMP_WORDS[COMP_CWORD-1]}"

    # Commands
    local commands="diagnose doctor compare sbom research deepcontext library generate explain best-practices tutorial interactive debug self-diagnose heal monitor templates health"

    # Global flags
    local flags="--help --version --quiet --verbose --debug --json --plain --no-input --no-color --dry-run"

    # Suggest commands on first argument
    if [[ \${COMP_CWORD} -eq 1 ]]; then
        COMPREPLY=(\$(compgen -W "\${commands}" -- "\${cur}"))
        return
    fi

    # Suggest flags after commands
    if [[ "\${cur}" == -* ]]; then
        COMPREPLY=(\$(compgen -W "\${flags}" -- "\${cur}"))
        return
    fi
}

complete -F _${name}_completions ${name}
`;
}
